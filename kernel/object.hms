(provide! (this make-object object? send clone)
  (define this (make-dynvar ()))

  (define (object object? deobject) (make-encapsulation-type))

  (define make-object
    (vau body e
      (let ((env (make-object-environment e)))
        (eval (cons list body) env)
        (object env))))

  (defn (clone o)
    (make-object (delegate-to o)))

  (define send
    (vau (target msg . args) e
      (define obj (eval target e))
      (send-from e obj obj msg args)))

  (defn (send-from e where obj msg args)
    (define env (deobject obj))
    (cond
      ((apply (wrap binds?) (list env msg))
        (with ((this where))
          (eval (list* (eval msg env) args) e)))

      ; try again on the parent object
      ((binds? env *parent*)
        (send-from e where (remote-eval *parent* env) msg args))

      (#t (fail (new message-not-understood where msg)))))

  (defn (make-object-environment e)
    (let* ((slots (make-environment))
           (obj (make-environment slots e)))
      (set! obj *parent* (object (make-environment)))

      (set! obj parent (remote-eval (lambda () *parent*) obj))

      (set! obj property
        (vau (x y) env
          (eval (list set! slots x (eval y env)) obj)
          (apply (wrap set!)
                (list obj x
                      (eval (list lambda () x) slots))
                obj)))

      (set! obj accessor
        (vau (what) #ignore
          (apply (wrap set!)
                 (list obj what (eval (list lambda () what) slots))
                 obj)))

      (set! obj delegate-to
        (lambda (to)
          (set! obj *parent* to)))

      (set! obj set
        (vau (where what) e
          (eval (list set! slots where what) e)))

      (set! obj responds-to?
        (vau (what) #ignore
          (or? (apply (wrap binds?) (list obj what))
               ((remote-eval *parent* obj) responds-to? what))))

      obj)))
