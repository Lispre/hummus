(provide! (this make-object object? send clone)
  (define this (make-dynvar ()))

  (record object (parent slots public private))
  (record method (args body context))

  (define make-object
    (vau body e
      (let ((obj (new-object e)))
        (eval (cons list body) (object-private obj))
        obj)))

  (defn (clone o)
    (make-object (delegates-to o)))

  (define send
    (vau (target msg . args) e
      (define obj (eval target e))
      (send-from e obj obj msg args)))

  (defn (send-from e where obj msg args)
    (define public (object-public obj))

    (cond
      ((apply (wrap binds?) (list public msg))
        (define meth (eval msg public))

        (eval
          (list*
            let-redirect
            (make-environment
              (object-slots where)
              (object-public where)
              (object-private where)
              (object-slots obj)
              (object-public obj)
              (method-context meth))
            (list (list (method-args meth) (cons list args)))
            (method-body meth))
          e))

      ((null? (object-parent obj))
        (fail (new message-not-understood where msg)))

      (#t (send-from e where (object-parent obj) msg args))))

  (defn (new-object e)
    (let* ((slots (make-environment))
           (public (make-environment))
           (private (make-environment e))
           (obj (object () slots public private)))
      (set! private *parent* (lambda () (object-parent obj)))

      (set! private property
        (vau (x y) env
          (apply (wrap set!) (list slots x (eval y env)))
          (apply (wrap set!) (list public x (eval (list lambda () x) slots)))))

      (set! private accessor
        (vau (what) #ignore
          (apply (wrap set!)
                 (list public what (eval (list lambda () what) slots)))))

      (set! private delegates-to
        (lambda (to)
          (set-object-parent! obj to)))

      (set! private set
        (vau (where what) e
          (eval (list set! slots where what) e)))

      (set! public responds-to?
        (vau (what) #ignore
          (or? (apply (wrap binds?) (list public what))
               (send (object-parent obj) responds-to? what))))

      (set! private public
        (vau ((name . args) . body) e
          (apply (wrap set!) (list slots name (vau args e (apply (wrap send) (list* obj name args) e))))
          (apply (wrap set!) (list public name (method args body e)))))

      (remote-eval (public (parent) (*parent*)) private)

      (remote-eval (public (delegate-to x) (delegates-to x)) private)

      obj)))
