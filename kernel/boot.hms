(define sequence
  ((wrap
     (vau (seq2) #ignore
          (seq2
            (define aux
              (vau (head . tail) env
                   (if (null? tail)
                     (eval head env)
                     (seq2
                       (eval head env)
                       (eval (cons aux tail) env)))))
            (vau body env
                 (if (null? body)
                   #inert
                   (eval (cons aux body) env))))))
   (vau (first second) env
        ((wrap (vau #ignore #ignore (eval second env)))
         (eval first env)))))

(define list (wrap (vau x #ignore x)))

(define list*
  (wrap
    (vau args #ignore
         (sequence
           (define aux
             (wrap
               (vau ((head . tail)) #ignore
                    (if (null? tail)
                      head
                      (cons head (aux tail))))))
           (aux args)))))

(define car (wrap (vau ((x . #ignore)) #ignore x)))
(define cdr (wrap (vau ((#ignore . x)) #ignore x)))

(define length
  (wrap
    (vau (x) #ignore
      (if (null? x)
        0
        (+ 1 (length (cdr x)))))))

(define vau
  ((wrap
     (vau (vau) #ignore
          (vau (formals eformal . body) env
               (eval (list vau formals eformal
                           (if (>? (length body) 1)
                             (cons sequence body)
                             (car body))) env))))
   vau))

(define lambda
  (vau (formals . body) env
       (wrap (eval (list* vau formals #ignore body) env))))

(define caar (lambda (((x . #ignore) . #ignore)) x))
(define cdar (lambda (((#ignore . x) . #ignore)) x))
(define cadr (lambda ((#ignore . (x . #ignore))) x))
(define cddr (lambda ((#ignore . (#ignore . x))) x))

(define caaar (lambda ((((x . #ignore) . #ignore) . #ignore)) x))
(define cdaar (lambda ((((#ignore . x) . #ignore) . #ignore)) x))
(define cadar (lambda (((#ignore . (x . #ignore)) . #ignore)) x))
(define cddar (lambda (((#ignore . (#ignore . x)) . #ignore)) x))
(define caadr (lambda ((#ignore . ((x . #ignore) . #ignore))) x))
(define cdadr (lambda ((#ignore . ((#ignore . x) . #ignore))) x))
(define caddr (lambda ((#ignore . (#ignore . (x . #ignore)))) x))
(define cdddr (lambda ((#ignore . (#ignore . (#ignore . x)))) x))

(define caaaar (lambda (((((x . #ignore) . #ignore) . #ignore). #ignore))x))
(define cdaaar (lambda (((((#ignore . x) . #ignore) . #ignore). #ignore))x))
(define cadaar (lambda ((((#ignore . (x . #ignore)) . #ignore). #ignore))x))
(define cddaar (lambda ((((#ignore . (#ignore . x)) . #ignore). #ignore))x))
(define caadar (lambda (((#ignore . ((x . #ignore) . #ignore)). #ignore))x))
(define cdadar (lambda (((#ignore . ((#ignore . x) . #ignore)). #ignore))x))
(define caddar (lambda (((#ignore . (#ignore . (x . #ignore))). #ignore))x))
(define cdddar (lambda (((#ignore . (#ignore . (#ignore . x))). #ignore))x))
(define caaadr (lambda ((#ignore .(((x . #ignore) . #ignore) . #ignore)))x))
(define cdaadr (lambda ((#ignore .(((#ignore . x) . #ignore) . #ignore)))x))
(define cadadr (lambda ((#ignore .((#ignore . (x . #ignore)) . #ignore)))x))
(define cddadr (lambda ((#ignore .((#ignore . (#ignore . x)) . #ignore)))x))
(define caaddr (lambda ((#ignore .(#ignore . ((x . #ignore) . #ignore))))x))
(define cdaddr (lambda ((#ignore .(#ignore . ((#ignore . x) . #ignore))))x))
(define cadddr (lambda ((#ignore .(#ignore . (#ignore . (x . #ignore)))))x))
(define cddddr (lambda ((#ignore .(#ignore . (#ignore . (#ignore . x)))))x))

(define apply
  (lambda (appv arg . opt)
    (eval (cons (unwrap appv) arg)
          (if (null? opt)
            (make-environment)
            (car opt)))))

(define cond
  (vau clauses env
       (define aux
         (lambda ((test . body) . clauses)
           (if (eval test env)
             (apply (wrap sequence) body env)
             (apply (wrap cond) clauses env))))
       (if (null? clauses)
         #inert
         (apply aux clauses))))

(define drop
  (lambda (ls k)
    (if (>? k 0)
      (drop (cdr ls) (- k 1))
      ls)))

(define map
  (lambda (f xs)
    (if (null? xs)
      ()
      (cons (f (car xs)) (map f (cdr xs))))))

(define any?
  (lambda (f xs)
    (cond
      ((null? xs) #f)
      ((f (car xs)) #t)
      (#t (any? f (cdr xs))))))

(define let
  (vau (bindings . body) env
    (eval (cons (list* lambda (map car bindings) body)
                (map cadr bindings))
          env)))

(define zip
  (lambda (f . xss)
    (let ((rest (map cdr xss)))
      (cons (apply f (map car xss))
            (if (any? null? rest)
              ()
              (apply zip (cons f rest)))))))

(define not? (lambda (x) (if x #f #t)))

(define and?
  (vau xs e
    (cond
      ((null? xs) #t)
      ((eval (car xs) e) (apply (wrap and?) (cdr xs) e))
      (#t #f))))

(define or?
  (vau xs e
    (cond
      ((null? xs) #f)
      ((eval (car xs) e) #t)
      (#t (apply (wrap or?) (cdr xs) e)))))

(define combiner?
  (lambda xs
    (apply (wrap and?) (map (lambda (x) (or? (operative? x) (applicative? x))) xs))))

(define at
  (lambda (n xs)
    (car (drop n xs))))

(define reduce
  (lambda (f a xs)
    (if (null? xs)
      a
      (reduce f (f a (car xs)) (cdr xs)))))

(define append
  (lambda xss
    (define append2
      (lambda (xs ys)
        (if (null? xs)
          ys
          (cons (car xs) (append2 (cdr xs) ys)))))

    (reduce append2 () xss)))
